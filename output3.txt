Token: Separator                 Lexeme: $
<Rat24S> -> $ <Opt Function Definitions>  $ <Opt Declaration List>  $ <Statement List>  $
Token: Keyword                   Lexeme: function
<Opt Function Definitions> -> <Function Definitions>
<Function Definitions> -> <Function> <Function Definition Prime>
<Function> -> function <Identifier> (<Opt Parameter List>) <Opt Declaration List> <Body>
Token: Identifier                Lexeme: max
Token: Separator                 Lexeme: (
Token: Identifier                Lexeme: a
<Opt Parameter List> -> <Parameter List> 
<Parameter List> -> <Parameter> <Parameter List Prime>
<Parameter> -> <IDs><Qualifier>
<IDs> -> <Identifier> <IDs Prime>
Token: Keyword                   Lexeme: integer
<IDs Prime> -> Epsilon
<Qualifier> -> integer
Token: Separator                 Lexeme: ,
<Parameter List Prime> ->,<Parameter List>
Token: Identifier                Lexeme: b
<Parameter List> -> <Parameter> <Parameter List Prime>
<Parameter> -> <IDs><Qualifier>
<IDs> -> <Identifier> <IDs Prime>
Token: Keyword                   Lexeme: integer
<IDs Prime> -> Epsilon
<Qualifier> -> integer
Token: Separator                 Lexeme: )
<Parameter List Prime> -> Epsilon 
Token: Separator                 Lexeme: {
<Opt Declaration List> -> <Empty>
<Empty> -> Epsilon
Token: Keyword                   Lexeme: if
<Body> -> {<Statement List>}
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <If>
<If> -> if (<Condition>) <Statement> <If Prime>
Token: Separator                 Lexeme: (
Token: Identifier                Lexeme: a
<Condition> -> <Expression> <Relop> <Expression>
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Token: Operator                  Lexeme: >
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
<Relop> -> >
Token: Identifier                Lexeme: b
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Token: Separator                 Lexeme: )
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
Token: Separator                 Lexeme: {
<Compound>> -> <Compound>
<Compound> -> {<Statement List>}
Token: Keyword                   Lexeme: return
<Body> -> {<Statement List>}
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <Return>
<Return> -> return <Return Prime>
Token: Identifier                Lexeme: a
<Return Prime> ->  ; |  <Expression>;
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Token: Separator                 Lexeme: ;
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
Token: Separator                 Lexeme: }
<Statement List Prime> -> <Empty>
<Empty> -> Epsilon
Token: Keyword                   Lexeme: else
<If'> -> else <Statement> endif
Token: Separator                 Lexeme: {
<Compound>> -> <Compound>
<Compound> -> {<Statement List>}
Token: Keyword                   Lexeme: return
<Body> -> {<Statement List>}
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <Return>
<Return> -> return <Return Prime>
Token: Identifier                Lexeme: b
<Return Prime> ->  ; |  <Expression>;
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>
Token: Separator                 Lexeme: ;
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
Token: Separator                 Lexeme: }
<Statement List Prime> -> <Empty>
<Empty> -> Epsilon
Token: Keyword                   Lexeme: endif
Token: Separator                 Lexeme: }
<Statement List Prime> -> <Empty>
<Empty> -> Epsilon
Token: Separator                 Lexeme: $
<Function Definitions Prime> -> Epsilon
Token: Keyword                   Lexeme: integer
<Opt Declaration List> -> <Declaration List>
<Declaration> -> <Qualifier><IDs>
<Qualifier> -> integer
Token: Identifier                Lexeme: result
<IDs> -> <Identifier> <IDs Prime>
Token: Separator                 Lexeme: ;
<IDs Prime> -> Epsilon
Token: Separator                 Lexeme: $
<Declaration List Prime> -> Epsilon
Token: Identifier                Lexeme: a
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <Assign>
<Assign> -> Identifier = <Expression>;
Token: Operator                  Lexeme: =
Token: Integer                   Lexeme: 10
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Integer>
Token: Separator                 Lexeme: ;
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
Token: Keyword                   Lexeme: scan
<Statement List Prime> -> <Statement List>
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <Scan>
<Scan> -> scan(<IDs>);
Token: Separator                 Lexeme: (
Token: Identifier                Lexeme: b
<IDs> -> <Identifier> <IDs Prime>
Token: Separator                 Lexeme: )
<IDs Prime> -> Epsilon
Token: Separator                 Lexeme: ;
Token: Keyword                   Lexeme: print
<Statement List Prime> -> <Statement List>
<Statement List> -> <Statement><Statement List Prime>
<Statement> -> <Print>
<Print> -> print(<Expression>)
Token: Separator                 Lexeme: (
Token: Identifier                Lexeme: max
<Expression> -> <Term><Expression Prime>
<Term> -> <Factor><Term Prime>
<Factor> -> <Primary>
<Primary> -> <Identifier>(<IDs>)
Token: Separator                 Lexeme: (
Token: Identifier                Lexeme: a
<IDs> -> <Identifier> <IDs Prime>
Token: Separator                 Lexeme: ,
<IDs Prime> -> <IDs>
Token: Identifier                Lexeme: b
<IDs> -> <Identifier> <IDs Prime>
Token: Separator                 Lexeme: )
<IDs Prime> -> Epsilon
<Term Prime> -> Epsilon
<Expression Prime> -> Epsilon
Token: Separator                 Lexeme: ;
Token: Separator                 Lexeme: $
<Statement List Prime> -> <Empty>
<Empty> -> Epsilon

| ~~~        End of File Reached      ~~~ |
| ~~~ Syntax Analyzer Found No Errors ~~~ |